#!/usr/bin/env python3\n\"\"\"\n字幕显示验证器 - 简化版本\n\"\"\"\nimport re\nimport uuid\nfrom typing import Dict, List, Optional, Any, Tuple\nfrom datetime import datetime\nfrom dataclasses import dataclass\nfrom enum import Enum\nfrom collections import defaultdict\n\nfrom config import get_logger\nfrom models.subtitle_models import SubtitleEntry\n\nlogger = get_logger(\"subtitle_display_validator\")\n\n\nclass ValidationSeverity(Enum):\n    CRITICAL = \"critical\"\n    HIGH = \"high\"\n    MEDIUM = \"medium\"\n    LOW = \"low\"\n    INFO = \"info\"\n\n\nclass ValidationType(Enum):\n    DURATION = \"duration\"\n    CHARACTER_COUNT = \"character_count\"\n    OVERLAP = \"overlap\"\n    FORMAT = \"format\"\n    READING_SPEED = \"reading_speed\"\n    TIMING = \"timing\"\n\n\nclass FixStrategy(Enum):\n    AUTO_FIX = \"auto_fix\"\n    SUGGEST_FIX = \"suggest_fix\"\n    MANUAL_REVIEW = \"manual_review\"\n\n\n@dataclass\nclass ValidationRule:\n    rule_id: str\n    rule_name: str\n    validation_type: ValidationType\n    severity: ValidationSeverity\n    fix_strategy: FixStrategy = FixStrategy.SUGGEST_FIX\n    description: str = \"\"\n    parameters: Dict[str, Any] = None\n    enabled: bool = True\n    \n    def __post_init__(self):\n        if self.parameters is None:\n            self.parameters = {}\n\n\n@dataclass\nclass ValidationIssue:\n    issue_id: str\n    rule_id: str\n    validation_type: ValidationType\n    severity: ValidationSeverity\n    subtitle_index: int\n    message: str = \"\"\n    details: Dict[str, Any] = None\n    suggested_fix: Optional[str] = None\n    can_auto_fix: bool = False\n    detected_at: datetime = None\n    \n    def __post_init__(self):\n        if self.details is None:\n            self.details = {}\n        if self.detected_at is None:\n            self.detected_at = datetime.now()\n\n\n@dataclass\nclass ValidationRequest:\n    request_id: str\n    subtitle_entries: List[SubtitleEntry]\n    target_language: str = \"en\"\n    auto_fix: bool = False\n    timestamp: datetime = None\n    \n    def __post_init__(self):\n        if self.timestamp is None:\n            self.timestamp = datetime.now()\n\n\n@dataclass\nclass ValidationResult:\n    request_id: str\n    success: bool\n    issues_found: List[ValidationIssue]\n    validation_score: float = 1.0\n    processing_time_ms: int = 0\n    recommendations: List[str] = None\n    \n    def __post_init__(self):\n        if self.recommendations is None:\n            self.recommendations = []\n\n\nclass SubtitleDisplayValidator:\n    \"\"\"字幕显示验证器\"\"\"\n    \n    def __init__(self, validator_id: str = None):\n        self.validator_id = validator_id or f\"validator_{uuid.uuid4().hex[:8]}\"\n        self.language_configs = {\n            \"en\": {\n                \"max_chars_per_line\": 42,\n                \"min_duration_ms\": 1000,\n                \"reading_speed_cps\": 17\n            },\n            \"zh\": {\n                \"max_chars_per_line\": 20,\n                \"min_duration_ms\": 1000,\n                \"reading_speed_cps\": 8\n            }\n        }\n        self.built_in_rules = self._initialize_rules()\n        logger.info(\"字幕显示验证器初始化完成\", validator_id=self.validator_id)\n    \n    def _initialize_rules(self) -> List[ValidationRule]:\n        return [\n            ValidationRule(\n                rule_id=\"min_duration\",\n                rule_name=\"最小显示时长\",\n                validation_type=ValidationType.DURATION,\n                severity=ValidationSeverity.HIGH,\n                fix_strategy=FixStrategy.AUTO_FIX\n            ),\n            ValidationRule(\n                rule_id=\"max_chars_per_line\",\n                rule_name=\"每行最大字符数\",\n                validation_type=ValidationType.CHARACTER_COUNT,\n                severity=ValidationSeverity.HIGH,\n                fix_strategy=FixStrategy.AUTO_FIX\n            ),\n            ValidationRule(\n                rule_id=\"overlap_detection\",\n                rule_name=\"字幕重叠检测\",\n                validation_type=ValidationType.OVERLAP,\n                severity=ValidationSeverity.CRITICAL,\n                fix_strategy=FixStrategy.AUTO_FIX\n            )\n        ]\n    \n    async def validate_subtitles(self, request: ValidationRequest) -> ValidationResult:\n        \"\"\"验证字幕\"\"\"\n        start_time = datetime.now()\n        \n        logger.info(\"开始字幕显示验证\", request_id=request.request_id)\n        \n        try:\n            lang_config = self.language_configs.get(request.target_language, self.language_configs[\"en\"])\n            issues = []\n            \n            # 执行验证\n            for i, subtitle in enumerate(request.subtitle_entries):\n                # 检查时长\n                duration_ms = subtitle.duration_seconds * 1000\n                min_duration = lang_config.get(\"min_duration_ms\", 1000)\n                if duration_ms < min_duration:\n                    issues.append(ValidationIssue(\n                        issue_id=f\"min_duration_{i}\",\n                        rule_id=\"min_duration\",\n                        validation_type=ValidationType.DURATION,\n                        severity=ValidationSeverity.HIGH,\n                        subtitle_index=i,\n                        message=f\"显示时长过短: {duration_ms}ms < {min_duration}ms\",\n                        can_auto_fix=True\n                    ))\n                \n                # 检查字符数\n                max_chars = lang_config.get(\"max_chars_per_line\", 42)\n                lines = subtitle.text.split('\\n')\n                for line_idx, line in enumerate(lines):\n                    if len(line) > max_chars:\n                        issues.append(ValidationIssue(\n                            issue_id=f\"max_chars_{i}_{line_idx}\",\n                            rule_id=\"max_chars_per_line\",\n                            validation_type=ValidationType.CHARACTER_COUNT,\n                            severity=ValidationSeverity.HIGH,\n                            subtitle_index=i,\n                            message=f\"第{line_idx+1}行字符数过多: {len(line)} > {max_chars}\",\n                            can_auto_fix=True\n                        ))\n            \n            # 检查重叠\n            for i in range(len(request.subtitle_entries) - 1):\n                current = request.subtitle_entries[i]\n                next_sub = request.subtitle_entries[i + 1]\n                if current.end_time > next_sub.start_time:\n                    overlap_ms = (current.end_time - next_sub.start_time) * 1000\n                    issues.append(ValidationIssue(\n                        issue_id=f\"overlap_{i}\",\n                        rule_id=\"overlap_detection\",\n                        validation_type=ValidationType.OVERLAP,\n                        severity=ValidationSeverity.CRITICAL,\n                        subtitle_index=i,\n                        message=f\"字幕重叠: {overlap_ms:.0f}ms\",\n                        can_auto_fix=True\n                    ))\n            \n            # 计算分数\n            validation_score = 1.0 if not issues else max(0.0, 1.0 - len(issues) * 0.1)\n            \n            # 生成建议\n            recommendations = []\n            if not issues:\n                recommendations.append(\"所有字幕都符合显示标准\")\n            else:\n                recommendations.append(f\"发现 {len(issues)} 个问题\")\n                auto_fixable = len([i for i in issues if i.can_auto_fix])\n                if auto_fixable > 0:\n                    recommendations.append(f\"其中 {auto_fixable} 个问题可以自动修复\")\n            \n            processing_time = (datetime.now() - start_time).total_seconds() * 1000\n            \n            result = ValidationResult(\n                request_id=request.request_id,\n                success=True,\n                issues_found=issues,\n                validation_score=validation_score,\n                processing_time_ms=int(processing_time),\n                recommendations=recommendations\n            )\n            \n            logger.info(\"字幕显示验证完成\", \n                       request_id=request.request_id,\n                       issues_count=len(issues),\n                       validation_score=validation_score)\n            \n            return result\n            \n        except Exception as e:\n            processing_time = (datetime.now() - start_time).total_seconds() * 1000\n            logger.error(\"字幕显示验证失败\", request_id=request.request_id, error=str(e))\n            \n            return ValidationResult(\n                request_id=request.request_id,\n                success=False,\n                issues_found=[],\n                validation_score=0.0,\n                processing_time_ms=int(processing_time),\n                recommendations=[f\"验证过程中发生错误: {str(e)}\"]\n            )\n    \n    def get_validation_statistics(self) -> Dict[str, Any]:\n        \"\"\"获取验证统计信息\"\"\"\n        return {\n            \"total_rules\": len(self.built_in_rules),\n            \"validator_id\": self.validator_id\n        }"