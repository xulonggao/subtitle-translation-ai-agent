#!/usr/bin/env python3\n\"\"\"\n字幕显示验证器\n实现字幕时长、字符数、重叠检测、格式验证等功能\n\"\"\"\nimport re\nimport uuid\nimport json\nfrom typing import Dict, List, Optional, Any, Tuple\nfrom datetime import datetime\nfrom dataclasses import dataclass, asdict\nfrom enum import Enum\nfrom collections import defaultdict\n\nfrom config import get_logger\nfrom models.subtitle_models import SubtitleEntry\n\nlogger = get_logger(\"subtitle_display_validator\")\n\n\nclass ValidationSeverity(Enum):\n    \"\"\"验证问题严重程度\"\"\"\n    CRITICAL = \"critical\"\n    HIGH = \"high\"\n    MEDIUM = \"medium\"\n    LOW = \"low\"\n    INFO = \"info\"\n\n\nclass ValidationType(Enum):\n    \"\"\"验证类型\"\"\"\n    DURATION = \"duration\"\n    CHARACTER_COUNT = \"character_count\"\n    OVERLAP = \"overlap\"\n    GAP = \"gap\"\n    FORMAT = \"format\"\n    READING_SPEED = \"reading_speed\"\n    LINE_COUNT = \"line_count\"\n    TIMING = \"timing\"\n\n\nclass FixStrategy(Enum):\n    \"\"\"修复策略\"\"\"\n    AUTO_FIX = \"auto_fix\"\n    SUGGEST_FIX = \"suggest_fix\"\n    MANUAL_REVIEW = \"manual_review\"\n    IGNORE = \"ignore\"\n\n\n@dataclass\nclass ValidationRule:\n    \"\"\"验证规则\"\"\"\n    rule_id: str\n    rule_name: str\n    validation_type: ValidationType\n    severity: ValidationSeverity\n    fix_strategy: FixStrategy = FixStrategy.SUGGEST_FIX\n    description: str = \"\"\n    parameters: Dict[str, Any] = None\n    enabled: bool = True\n    \n    def __post_init__(self):\n        if self.parameters is None:\n            self.parameters = {}\n\n\n@dataclass\nclass ValidationIssue:\n    \"\"\"验证问题\"\"\"\n    issue_id: str\n    rule_id: str\n    validation_type: ValidationType\n    severity: ValidationSeverity\n    subtitle_index: int\n    subtitle_id: Optional[str] = None\n    message: str = \"\"\n    details: Dict[str, Any] = None\n    suggested_fix: Optional[str] = None\n    fix_strategy: FixStrategy = FixStrategy.SUGGEST_FIX\n    can_auto_fix: bool = False\n    detected_at: datetime = None\n    \n    def __post_init__(self):\n        if self.details is None:\n            self.details = {}\n        if self.detected_at is None:\n            self.detected_at = datetime.now()\n\n\n@dataclass\nclass ValidationRequest:\n    \"\"\"验证请求\"\"\"\n    request_id: str\n    subtitle_entries: List[SubtitleEntry]\n    target_language: str = \"en\"\n    validation_rules: Optional[List[ValidationRule]] = None\n    auto_fix: bool = False\n    fix_threshold: ValidationSeverity = ValidationSeverity.HIGH\n    metadata: Optional[Dict[str, Any]] = None\n    timestamp: datetime = None\n    \n    def __post_init__(self):\n        if self.metadata is None:\n            self.metadata = {}\n        if self.timestamp is None:\n            self.timestamp = datetime.now()\n        if self.validation_rules is None:\n            self.validation_rules = []\n\n\n@dataclass\nclass ValidationResult:\n    \"\"\"验证结果\"\"\"\n    request_id: str\n    success: bool\n    issues_found: List[ValidationIssue]\n    fixed_issues: List[ValidationIssue] = None\n    fixed_subtitles: Optional[List[SubtitleEntry]] = None\n    validation_score: float = 1.0\n    issues_by_type: Dict[ValidationType, int] = None\n    issues_by_severity: Dict[ValidationSeverity, int] = None\n    processing_time_ms: int = 0\n    recommendations: List[str] = None\n    metadata: Optional[Dict[str, Any]] = None\n    timestamp: datetime = None\n    \n    def __post_init__(self):\n        if self.fixed_issues is None:\n            self.fixed_issues = []\n        if self.issues_by_type is None:\n            self.issues_by_type = {}\n        if self.issues_by_severity is None:\n            self.issues_by_severity = {}\n        if self.recommendations is None:\n            self.recommendations = []\n        if self.metadata is None:\n            self.metadata = {}\n        if self.timestamp is None:\n            self.timestamp = datetime.now()\n\n\nclass SubtitleDisplayValidator:\n    \"\"\"字幕显示验证器\"\"\"\n    \n    def __init__(self, validator_id: str = None):\n        self.validator_id = validator_id or f\"display_validator_{uuid.uuid4().hex[:8]}\"\n        self.language_configs = self._initialize_language_configs()\n        self.built_in_rules = self._initialize_built_in_rules()\n        self.custom_rules: List[ValidationRule] = []\n        self.validation_stats = {\n            \"total_validations\": 0,\n            \"issues_found\": 0,\n            \"issues_fixed\": 0,\n            \"validation_scores\": [],\n            \"issue_types\": defaultdict(int),\n            \"processing_times\": []\n        }\n        logger.info(\"字幕显示验证器初始化完成\", validator_id=self.validator_id)\n    \n    def _initialize_language_configs(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"初始化语言配置\"\"\"\n        return {\n            \"en\": {\n                \"max_chars_per_line\": 42,\n                \"max_lines\": 2,\n                \"min_duration_ms\": 1000,\n                \"max_duration_ms\": 7000,\n                \"reading_speed_cps\": 17,\n                \"min_gap_ms\": 250,\n                \"max_chars_total\": 84\n            },\n            \"zh\": {\n                \"max_chars_per_line\": 20,\n                \"max_lines\": 2,\n                \"min_duration_ms\": 1000,\n                \"max_duration_ms\": 6000,\n                \"reading_speed_cps\": 8,\n                \"min_gap_ms\": 250,\n                \"max_chars_total\": 40\n            },\n            \"ja\": {\n                \"max_chars_per_line\": 18,\n                \"max_lines\": 2,\n                \"min_duration_ms\": 1200,\n                \"max_duration_ms\": 6000,\n                \"reading_speed_cps\": 9,\n                \"min_gap_ms\": 300,\n                \"max_chars_total\": 36\n            }\n        }\n    \n    def _initialize_built_in_rules(self) -> List[ValidationRule]:\n        \"\"\"初始化内置验证规则\"\"\"\n        return [\n            ValidationRule(\n                rule_id=\"min_duration\",\n                rule_name=\"最小显示时长\",\n                validation_type=ValidationType.DURATION,\n                severity=ValidationSeverity.HIGH,\n                fix_strategy=FixStrategy.AUTO_FIX,\n                description=\"检查字幕显示时长是否达到最小要求\",\n                parameters={\"min_duration_ms\": 1000}\n            ),\n            ValidationRule(\n                rule_id=\"max_chars_per_line\",\n                rule_name=\"每行最大字符数\",\n                validation_type=ValidationType.CHARACTER_COUNT,\n                severity=ValidationSeverity.HIGH,\n                fix_strategy=FixStrategy.AUTO_FIX,\n                description=\"检查每行字符数是否超过限制\",\n                parameters={\"max_chars\": 42}\n            ),\n            ValidationRule(\n                rule_id=\"overlap_detection\",\n                rule_name=\"字幕重叠检测\",\n                validation_type=ValidationType.OVERLAP,\n                severity=ValidationSeverity.CRITICAL,\n                fix_strategy=FixStrategy.AUTO_FIX,\n                description=\"检测字幕时间重叠问题\"\n            ),\n            ValidationRule(\n                rule_id=\"text_format\",\n                rule_name=\"文本格式\",\n                validation_type=ValidationType.FORMAT,\n                severity=ValidationSeverity.MEDIUM,\n                fix_strategy=FixStrategy.AUTO_FIX,\n                description=\"检查文本格式问题\"\n            ),\n            ValidationRule(\n                rule_id=\"reading_speed\",\n                rule_name=\"阅读速度\",\n                validation_type=ValidationType.READING_SPEED,\n                severity=ValidationSeverity.HIGH,\n                fix_strategy=FixStrategy.AUTO_FIX,\n                description=\"检查字幕阅读速度是否合理\",\n                parameters={\"max_cps\": 20}\n            )\n        ]"    as
ync def validate_subtitles(self, request: ValidationRequest) -> ValidationResult:\n        \"\"\"验证字幕\"\"\"\n        start_time = datetime.now()\n        \n        logger.info(\"开始字幕显示验证\",\n                   request_id=request.request_id,\n                   subtitles_count=len(request.subtitle_entries),\n                   target_language=request.target_language)\n        \n        try:\n            all_rules = self.built_in_rules + self.custom_rules + (request.validation_rules or [])\n            enabled_rules = [rule for rule in all_rules if rule.enabled]\n            lang_config = self.language_configs.get(request.target_language, self.language_configs[\"en\"])\n            \n            issues = []\n            \n            # 执行各种验证\n            issues.extend(self._validate_duration_and_characters(request.subtitle_entries, enabled_rules, lang_config))\n            issues.extend(self._validate_overlaps_and_gaps(request.subtitle_entries, enabled_rules, lang_config))\n            issues.extend(self._validate_format(request.subtitle_entries, enabled_rules))\n            issues.extend(self._validate_reading_speed(request.subtitle_entries, enabled_rules, lang_config))\n            issues.extend(self._validate_timing_sequence(request.subtitle_entries, enabled_rules))\n            \n            # 自动修复\n            fixed_issues = []\n            fixed_subtitles = None\n            if request.auto_fix:\n                fixed_subtitles, fixed_issues = await self._auto_fix_issues(\n                    request.subtitle_entries, issues, request.fix_threshold\n                )\n            \n            validation_score = self._calculate_validation_score(issues, len(request.subtitle_entries))\n            issues_by_type = self._count_issues_by_type(issues)\n            issues_by_severity = self._count_issues_by_severity(issues)\n            recommendations = self._generate_recommendations(issues)\n            \n            processing_time = (datetime.now() - start_time).total_seconds() * 1000\n            \n            result = ValidationResult(\n                request_id=request.request_id,\n                success=True,\n                issues_found=issues,\n                fixed_issues=fixed_issues,\n                fixed_subtitles=fixed_subtitles,\n                validation_score=validation_score,\n                issues_by_type=issues_by_type,\n                issues_by_severity=issues_by_severity,\n                processing_time_ms=int(processing_time),\n                recommendations=recommendations,\n                metadata={\n                    \"subtitles_count\": len(request.subtitle_entries),\n                    \"rules_applied\": len(enabled_rules),\n                    \"language\": request.target_language\n                }\n            )\n            \n            self._update_validation_stats(request, result)\n            \n            logger.info(\"字幕显示验证完成\",\n                       request_id=request.request_id,\n                       validation_score=validation_score,\n                       issues_count=len(issues),\n                       processing_time_ms=int(processing_time))\n            \n            return result\n            \n        except Exception as e:\n            processing_time = (datetime.now() - start_time).total_seconds() * 1000\n            \n            logger.error(\"字幕显示验证失败\",\n                        request_id=request.request_id,\n                        error=str(e),\n                        processing_time_ms=int(processing_time))\n            \n            return ValidationResult(\n                request_id=request.request_id,\n                success=False,\n                issues_found=[],\n                validation_score=0.0,\n                processing_time_ms=int(processing_time),\n                recommendations=[f\"验证过程中发生错误: {str(e)}\"]\n            )"   
 def _validate_duration_and_characters(self, subtitles: List[SubtitleEntry], \n                                         rules: List[ValidationRule],\n                                         lang_config: Dict[str, Any]) -> List[ValidationIssue]:\n        \"\"\"验证时长和字符数\"\"\"\n        issues = []\n        \n        for i, subtitle in enumerate(subtitles):\n            duration_ms = subtitle.duration_seconds * 1000\n            lines = subtitle.text.split('\\n')\n            \n            # 检查最小时长\n            min_duration_rule = next((r for r in rules if r.rule_id == \"min_duration\"), None)\n            if min_duration_rule and min_duration_rule.enabled:\n                min_duration = lang_config.get(\"min_duration_ms\", 1000)\n                if duration_ms < min_duration:\n                    issues.append(ValidationIssue(\n                        issue_id=f\"min_duration_{i}\",\n                        rule_id=min_duration_rule.rule_id,\n                        validation_type=ValidationType.DURATION,\n                        severity=min_duration_rule.severity,\n                        subtitle_index=i,\n                        message=f\"显示时长过短: {duration_ms}ms < {min_duration}ms\",\n                        details={\n                            \"current_duration_ms\": duration_ms,\n                            \"min_duration_ms\": min_duration\n                        },\n                        suggested_fix=f\"建议延长显示时间至 {min_duration}ms\",\n                        fix_strategy=min_duration_rule.fix_strategy,\n                        can_auto_fix=True\n                    ))\n            \n            # 检查每行字符数\n            max_chars_rule = next((r for r in rules if r.rule_id == \"max_chars_per_line\"), None)\n            if max_chars_rule and max_chars_rule.enabled:\n                max_chars = lang_config.get(\"max_chars_per_line\", 42)\n                for line_idx, line in enumerate(lines):\n                    if len(line) > max_chars:\n                        issues.append(ValidationIssue(\n                            issue_id=f\"max_chars_line_{i}_{line_idx}\",\n                            rule_id=max_chars_rule.rule_id,\n                            validation_type=ValidationType.CHARACTER_COUNT,\n                            severity=max_chars_rule.severity,\n                            subtitle_index=i,\n                            message=f\"第{line_idx+1}行字符数过多: {len(line)} > {max_chars}\",\n                            details={\n                                \"line_index\": line_idx,\n                                \"line_length\": len(line),\n                                \"max_chars\": max_chars\n                            },\n                            suggested_fix=f\"建议将该行分割或缩短至 {max_chars} 字符以内\",\n                            fix_strategy=max_chars_rule.fix_strategy,\n                            can_auto_fix=True\n                        ))\n        \n        return issues\n    \n    def _validate_overlaps_and_gaps(self, subtitles: List[SubtitleEntry],\n                                   rules: List[ValidationRule],\n                                   lang_config: Dict[str, Any]) -> List[ValidationIssue]:\n        \"\"\"验证重叠和间隔\"\"\"\n        issues = []\n        \n        if len(subtitles) < 2:\n            return issues\n        \n        overlap_rule = next((r for r in rules if r.rule_id == \"overlap_detection\"), None)\n        \n        for i in range(len(subtitles) - 1):\n            current = subtitles[i]\n            next_subtitle = subtitles[i + 1]\n            \n            # 检查重叠\n            if overlap_rule and overlap_rule.enabled:\n                if current.end_time > next_subtitle.start_time:\n                    overlap_ms = (current.end_time - next_subtitle.start_time) * 1000\n                    issues.append(ValidationIssue(\n                        issue_id=f\"overlap_{i}_{i+1}\",\n                        rule_id=overlap_rule.rule_id,\n                        validation_type=ValidationType.OVERLAP,\n                        severity=overlap_rule.severity,\n                        subtitle_index=i,\n                        message=f\"字幕重叠: 第{i+1}条与第{i+2}条重叠 {overlap_ms:.0f}ms\",\n                        details={\n                            \"current_end\": current.end_time,\n                            \"next_start\": next_subtitle.start_time,\n                            \"overlap_ms\": overlap_ms,\n                            \"next_index\": i + 1\n                        },\n                        suggested_fix=f\"建议调整第{i+1}条结束时间至 {next_subtitle.start_time}s\",\n                        fix_strategy=overlap_rule.fix_strategy,\n                        can_auto_fix=True\n                    ))\n        \n        return issues"    def
 _validate_format(self, subtitles: List[SubtitleEntry],\n                        rules: List[ValidationRule]) -> List[ValidationIssue]:\n        \"\"\"验证格式\"\"\"\n        issues = []\n        \n        format_rule = next((r for r in rules if r.rule_id == \"text_format\"), None)\n        if not format_rule or not format_rule.enabled:\n            return issues\n        \n        for i, subtitle in enumerate(subtitles):\n            text = subtitle.text\n            \n            # 检查多余的空格\n            if \"  \" in text:\n                issues.append(ValidationIssue(\n                    issue_id=f\"double_space_{i}\",\n                    rule_id=format_rule.rule_id,\n                    validation_type=ValidationType.FORMAT,\n                    severity=ValidationSeverity.LOW,\n                    subtitle_index=i,\n                    message=\"文本包含多余的空格\",\n                    details={\"text\": text},\n                    suggested_fix=\"建议清理多余的空格\",\n                    fix_strategy=FixStrategy.AUTO_FIX,\n                    can_auto_fix=True\n                ))\n            \n            # 检查开头或结尾的空格\n            if text.startswith(\" \") or text.endswith(\" \"):\n                issues.append(ValidationIssue(\n                    issue_id=f\"trim_space_{i}\",\n                    rule_id=format_rule.rule_id,\n                    validation_type=ValidationType.FORMAT,\n                    severity=ValidationSeverity.LOW,\n                    subtitle_index=i,\n                    message=\"文本开头或结尾有多余空格\",\n                    details={\"text\": text},\n                    suggested_fix=\"建议去除开头和结尾的空格\",\n                    fix_strategy=FixStrategy.AUTO_FIX,\n                    can_auto_fix=True\n                ))\n        \n        return issues\n    \n    def _validate_reading_speed(self, subtitles: List[SubtitleEntry],\n                               rules: List[ValidationRule],\n                               lang_config: Dict[str, Any]) -> List[ValidationIssue]:\n        \"\"\"验证阅读速度\"\"\"\n        issues = []\n        \n        reading_rule = next((r for r in rules if r.rule_id == \"reading_speed\"), None)\n        if not reading_rule or not reading_rule.enabled:\n            return issues\n        \n        max_cps = lang_config.get(\"reading_speed_cps\", 17)\n        \n        for i, subtitle in enumerate(subtitles):\n            text_length = len(subtitle.text.replace(\"\\n\", \"\"))\n            duration_seconds = subtitle.duration_seconds\n            \n            if duration_seconds > 0:\n                current_cps = text_length / duration_seconds\n                \n                if current_cps > max_cps:\n                    issues.append(ValidationIssue(\n                        issue_id=f\"reading_speed_{i}\",\n                        rule_id=reading_rule.rule_id,\n                        validation_type=ValidationType.READING_SPEED,\n                        severity=reading_rule.severity,\n                        subtitle_index=i,\n                        message=f\"阅读速度过快: {current_cps:.1f} > {max_cps} 字符/秒\",\n                        details={\n                            \"text_length\": text_length,\n                            \"duration_seconds\": duration_seconds,\n                            \"current_cps\": current_cps,\n                            \"max_cps\": max_cps\n                        },\n                        suggested_fix=f\"建议延长显示时间至 {text_length / max_cps:.1f}秒\",\n                        fix_strategy=reading_rule.fix_strategy,\n                        can_auto_fix=True\n                    ))\n        \n        return issues\n    \n    def _validate_timing_sequence(self, subtitles: List[SubtitleEntry],\n                                 rules: List[ValidationRule]) -> List[ValidationIssue]:\n        \"\"\"验证时间序列\"\"\"\n        issues = []\n        \n        for i, subtitle in enumerate(subtitles):\n            # 检查开始时间是否大于等于结束时间\n            if subtitle.start_time >= subtitle.end_time:\n                issues.append(ValidationIssue(\n                    issue_id=f\"invalid_duration_{i}\",\n                    rule_id=\"time_sequence\",\n                    validation_type=ValidationType.TIMING,\n                    severity=ValidationSeverity.CRITICAL,\n                    subtitle_index=i,\n                    message=f\"无效的时间范围: 开始时间 {subtitle.start_time}s >= 结束时间 {subtitle.end_time}s\",\n                    details={\n                        \"start_time\": subtitle.start_time,\n                        \"end_time\": subtitle.end_time\n                    },\n                    suggested_fix=\"建议检查并修正时间设置\",\n                    fix_strategy=FixStrategy.MANUAL_REVIEW,\n                    can_auto_fix=False\n                ))\n        \n        return issues" 
   async def _auto_fix_issues(self, subtitles: List[SubtitleEntry],\n                              issues: List[ValidationIssue],\n                              fix_threshold: ValidationSeverity) -> Tuple[List[SubtitleEntry], List[ValidationIssue]]:\n        \"\"\"自动修复问题\"\"\"\n        fixed_subtitles = [subtitle.copy() for subtitle in subtitles]\n        fixed_issues = []\n        \n        severity_order = {\n            ValidationSeverity.CRITICAL: 0,\n            ValidationSeverity.HIGH: 1,\n            ValidationSeverity.MEDIUM: 2,\n            ValidationSeverity.LOW: 3,\n            ValidationSeverity.INFO: 4\n        }\n        \n        fixable_issues = [\n            issue for issue in issues \n            if issue.can_auto_fix and severity_order.get(issue.severity, 4) <= severity_order.get(fix_threshold, 4)\n        ]\n        \n        for issue in fixable_issues:\n            try:\n                if self._apply_fix(fixed_subtitles, issue):\n                    fixed_issues.append(issue)\n            except Exception as e:\n                logger.warning(\"自动修复失败\", issue_id=issue.issue_id, error=str(e))\n        \n        return fixed_subtitles, fixed_issues\n    \n    def _apply_fix(self, subtitles: List[SubtitleEntry], issue: ValidationIssue) -> bool:\n        \"\"\"应用修复\"\"\"\n        if issue.subtitle_index >= len(subtitles):\n            return False\n        \n        subtitle = subtitles[issue.subtitle_index]\n        \n        try:\n            if issue.validation_type == ValidationType.DURATION:\n                if issue.rule_id == \"min_duration\":\n                    min_duration_s = issue.details[\"min_duration_ms\"] / 1000\n                    subtitle.end_time = subtitle.start_time + min_duration_s\n                    return True\n            \n            elif issue.validation_type == ValidationType.FORMAT:\n                if \"double_space\" in issue.issue_id:\n                    subtitle.text = re.sub(r'\\s+', ' ', subtitle.text)\n                    return True\n                elif \"trim_space\" in issue.issue_id:\n                    subtitle.text = subtitle.text.strip()\n                    return True\n            \n            elif issue.validation_type == ValidationType.OVERLAP:\n                next_start = issue.details[\"next_start\"]\n                subtitle.end_time = next_start - 0.001\n                return True\n            \n            elif issue.validation_type == ValidationType.READING_SPEED:\n                text_length = issue.details[\"text_length\"]\n                max_cps = issue.details[\"max_cps\"]\n                new_duration = text_length / max_cps\n                subtitle.end_time = subtitle.start_time + new_duration\n                return True\n            \n        except Exception as e:\n            logger.error(\"应用修复时出错\", issue_id=issue.issue_id, error=str(e))\n            return False\n        \n        return False\n    \n    def _calculate_validation_score(self, issues: List[ValidationIssue], subtitle_count: int) -> float:\n        \"\"\"计算验证分数\"\"\"\n        if not issues:\n            return 1.0\n        \n        severity_weights = {\n            ValidationSeverity.CRITICAL: 0.3,\n            ValidationSeverity.HIGH: 0.2,\n            ValidationSeverity.MEDIUM: 0.1,\n            ValidationSeverity.LOW: 0.05,\n            ValidationSeverity.INFO: 0.01\n        }\n        \n        total_penalty = sum(severity_weights.get(issue.severity, 0.1) for issue in issues)\n        normalized_penalty = total_penalty / max(subtitle_count, 1)\n        score = max(0.0, 1.0 - normalized_penalty)\n        \n        return score\n    \n    def _count_issues_by_type(self, issues: List[ValidationIssue]) -> Dict[ValidationType, int]:\n        \"\"\"按类型统计问题\"\"\"\n        counts = defaultdict(int)\n        for issue in issues:\n            counts[issue.validation_type] += 1\n        return dict(counts)\n    \n    def _count_issues_by_severity(self, issues: List[ValidationIssue]) -> Dict[ValidationSeverity, int]:\n        \"\"\"按严重程度统计问题\"\"\"\n        counts = defaultdict(int)\n        for issue in issues:\n            counts[issue.severity] += 1\n        return dict(counts)\n    \n    def _generate_recommendations(self, issues: List[ValidationIssue]) -> List[str]:\n        \"\"\"生成改进建议\"\"\"\n        recommendations = []\n        \n        if not issues:\n            recommendations.append(\"恭喜！所有字幕都符合显示标准。\")\n            return recommendations\n        \n        critical_issues = [i for i in issues if i.severity == ValidationSeverity.CRITICAL]\n        high_issues = [i for i in issues if i.severity == ValidationSeverity.HIGH]\n        \n        if critical_issues:\n            recommendations.append(f\"发现 {len(critical_issues)} 个严重问题，必须立即修复\")\n        \n        if high_issues:\n            recommendations.append(f\"发现 {len(high_issues)} 个高优先级问题，建议优先处理\")\n        \n        auto_fixable = len([i for i in issues if i.can_auto_fix])\n        if auto_fixable > 0:\n            recommendations.append(f\"其中 {auto_fixable} 个问题可以自动修复\")\n        \n        return recommendations\n    \n    def _update_validation_stats(self, request: ValidationRequest, result: ValidationResult):\n        \"\"\"更新验证统计\"\"\"\n        self.validation_stats[\"total_validations\"] += 1\n        self.validation_stats[\"issues_found\"] += len(result.issues_found)\n        self.validation_stats[\"issues_fixed\"] += len(result.fixed_issues)\n        self.validation_stats[\"validation_scores\"].append(result.validation_score)\n        self.validation_stats[\"processing_times\"].append(result.processing_time_ms)\n    \n    def get_validation_statistics(self) -> Dict[str, Any]:\n        \"\"\"获取验证统计信息\"\"\"\n        stats = self.validation_stats.copy()\n        \n        if stats[\"validation_scores\"]:\n            stats[\"average_validation_score\"] = sum(stats[\"validation_scores\"]) / len(stats[\"validation_scores\"])\n        else:\n            stats[\"average_validation_score\"] = 0.0\n        \n        if stats[\"processing_times\"]:\n            stats[\"average_processing_time_ms\"] = sum(stats[\"processing_times\"]) / len(stats[\"processing_times\"])\n        else:\n            stats[\"average_processing_time_ms\"] = 0.0\n        \n        stats[\"total_rules\"] = len(self.built_in_rules) + len(self.custom_rules)\n        \n        return stats"