#!/usr/bin/env python3\n\"\"\"\n字幕显示验证器测试\n\"\"\"\nimport unittest\nimport asyncio\nfrom datetime import datetime\n\nfrom agents.subtitle_display_validator import (\n    SubtitleDisplayValidator, ValidationRequest, ValidationRule,\n    ValidationType, ValidationSeverity, FixStrategy\n)\nfrom models.subtitle_models import SubtitleEntry\n\n\nclass TestSubtitleDisplayValidator(unittest.TestCase):\n    \"\"\"字幕显示验证器测试\"\"\"\n    \n    def setUp(self):\n        \"\"\"设置测试环境\"\"\"\n        self.validator = SubtitleDisplayValidator(\"test_validator\")\n        \n        # 创建测试字幕数据\n        self.test_subtitles = [\n            # 正常字幕\n            SubtitleEntry(\n                index=1,\n                start_time=0.0,\n                end_time=3.0,\n                text=\"Welcome to our program.\",\n                speaker=\"Host\"\n            ),\n            # 时长过短的字幕\n            SubtitleEntry(\n                index=2,\n                start_time=3.0,\n                end_time=3.5,  # 只有0.5秒\n                text=\"This is a short subtitle.\",\n                speaker=\"Host\"\n            ),\n            # 字符数过多的字幕\n            SubtitleEntry(\n                index=3,\n                start_time=4.0,\n                end_time=7.0,\n                text=\"This is an extremely long subtitle that definitely exceeds the recommended character limit for subtitles and should be flagged.\",\n                speaker=\"Guest\"\n            ),\n            # 重叠的字幕\n            SubtitleEntry(\n                index=4,\n                start_time=6.5,  # 与上一个字幕重叠\n                end_time=9.0,\n                text=\"This subtitle overlaps with the previous one.\",\n                speaker=\"Guest\"\n            ),\n            # 格式问题的字幕\n            SubtitleEntry(\n                index=5,\n                start_time=10.0,\n                end_time=13.0,\n                text=\"  This   has   multiple   spaces  \\n\\n  and extra newlines  \",\n                speaker=\"Host\"\n            )\n        ]\n    \n    def test_validator_initialization(self):\n        \"\"\"测试验证器初始化\"\"\"\n        self.assertIsNotNone(self.validator.validator_id)\n        self.assertGreater(len(self.validator.built_in_rules), 0)\n        self.assertEqual(len(self.validator.custom_rules), 0)\n        self.assertIn(\"en\", self.validator.language_configs)\n        self.assertIn(\"zh\", self.validator.language_configs)\n    \n    def test_validation_request_creation(self):\n        \"\"\"测试验证请求创建\"\"\"\n        request = ValidationRequest(\n            request_id=\"test_request_1\",\n            subtitle_entries=self.test_subtitles,\n            target_language=\"en\",\n            auto_fix=True\n        )\n        \n        self.assertEqual(request.request_id, \"test_request_1\")\n        self.assertEqual(len(request.subtitle_entries), 5)\n        self.assertEqual(request.target_language, \"en\")\n        self.assertTrue(request.auto_fix)\n        self.assertIsNotNone(request.timestamp)\n    \n    def test_duration_validation(self):\n        \"\"\"测试时长验证\"\"\"\n        # 创建只有时长问题的字幕\n        short_subtitle = SubtitleEntry(\n            index=1,\n            start_time=0.0,\n            end_time=0.5,  # 500ms，低于最小要求\n            text=\"Short\",\n            speaker=\"Test\"\n        )\n        \n        request = ValidationRequest(\n            request_id=\"duration_test\",\n            subtitle_entries=[short_subtitle],\n            target_language=\"en\"\n        )\n        \n        result = asyncio.run(self.validator.validate_subtitles(request))\n        \n        self.assertTrue(result.success)\n        self.assertGreater(len(result.issues_found), 0)\n        \n        # 检查是否发现了时长问题\n        duration_issues = [i for i in result.issues_found if i.validation_type == ValidationType.DURATION]\n        self.assertGreater(len(duration_issues), 0)\n    \n    def test_character_count_validation(self):\n        \"\"\"测试字符数验证\"\"\"\n        # 创建字符数过多的字幕\n        long_subtitle = SubtitleEntry(\n            index=1,\n            start_time=0.0,\n            end_time=5.0,\n            text=\"This is an extremely long subtitle that definitely exceeds the recommended character limit for subtitles and should be flagged by the validation system.\",\n            speaker=\"Test\"\n        )\n        \n        request = ValidationRequest(\n            request_id=\"char_count_test\",\n            subtitle_entries=[long_subtitle],\n            target_language=\"en\"\n        )\n        \n        result = asyncio.run(self.validator.validate_subtitles(request))\n        \n        self.assertTrue(result.success)\n        \n        # 检查是否发现了字符数问题\n        char_issues = [i for i in result.issues_found if i.validation_type == ValidationType.CHARACTER_COUNT]\n        self.assertGreater(len(char_issues), 0)\n    \n    def test_overlap_detection(self):\n        \"\"\"测试重叠检测\"\"\"\n        # 创建重叠的字幕\n        overlapping_subtitles = [\n            SubtitleEntry(\n                index=1,\n                start_time=0.0,\n                end_time=3.0,\n                text=\"First subtitle\",\n                speaker=\"Test\"\n            ),\n            SubtitleEntry(\n                index=2,\n                start_time=2.5,  # 与第一个重叠\n                end_time=5.0,\n                text=\"Second subtitle\",\n                speaker=\"Test\"\n            )\n        ]\n        \n        request = ValidationRequest(\n            request_id=\"overlap_test\",\n            subtitle_entries=overlapping_subtitles,\n            target_language=\"en\"\n        )\n        \n        result = asyncio.run(self.validator.validate_subtitles(request))\n        \n        self.assertTrue(result.success)\n        \n        # 检查是否发现了重叠问题\n        overlap_issues = [i for i in result.issues_found if i.validation_type == ValidationType.OVERLAP]\n        self.assertGreater(len(overlap_issues), 0)\n    \n    def test_format_validation(self):\n        \"\"\"测试格式验证\"\"\"\n        # 创建格式问题的字幕\n        messy_subtitle = SubtitleEntry(\n            index=1,\n            start_time=0.0,\n            end_time=3.0,\n            text=\"  This   has   multiple   spaces  \\n\\n  and extra newlines  \",\n            speaker=\"Test\"\n        )\n        \n        request = ValidationRequest(\n            request_id=\"format_test\",\n            subtitle_entries=[messy_subtitle],\n            target_language=\"en\"\n        )\n        \n        result = asyncio.run(self.validator.validate_subtitles(request))\n        \n        self.assertTrue(result.success)\n        \n        # 检查是否发现了格式问题\n        format_issues = [i for i in result.issues_found if i.validation_type == ValidationType.FORMAT]\n        self.assertGreater(len(format_issues), 0)\n    \n    def test_reading_speed_validation(self):\n        \"\"\"测试阅读速度验证\"\"\"\n        # 创建阅读速度过快的字幕\n        fast_subtitle = SubtitleEntry(\n            index=1,\n            start_time=0.0,\n            end_time=1.0,  # 1秒\n            text=\"This is a very long subtitle with many characters that cannot be read in just one second by any normal person.\",  # 很长的文本\n            speaker=\"Test\"\n        )\n        \n        request = ValidationRequest(\n            request_id=\"reading_speed_test\",\n            subtitle_entries=[fast_subtitle],\n            target_language=\"en\"\n        )\n        \n        result = asyncio.run(self.validator.validate_subtitles(request))\n        \n        self.assertTrue(result.success)\n        \n        # 检查是否发现了阅读速度问题\n        speed_issues = [i for i in result.issues_found if i.validation_type == ValidationType.READING_SPEED]\n        self.assertGreater(len(speed_issues), 0)\n    \n    def test_timing_sequence_validation(self):\n        \"\"\"测试时间序列验证\"\"\"\n        # 创建时间序列问题的字幕\n        invalid_timing_subtitles = [\n            SubtitleEntry(\n                index=1,\n                start_time=5.0,  # 开始时间晚于第二个字幕\n                end_time=8.0,\n                text=\"First subtitle\",\n                speaker=\"Test\"\n            ),\n            SubtitleEntry(\n                index=2,\n                start_time=2.0,  # 开始时间早于第一个字幕\n                end_time=4.0,\n                text=\"Second subtitle\",\n                speaker=\"Test\"\n            )\n        ]\n        \n        request = ValidationRequest(\n            request_id=\"timing_test\",\n            subtitle_entries=invalid_timing_subtitles,\n            target_language=\"en\"\n        )\n        \n        result = asyncio.run(self.validator.validate_subtitles(request))\n        \n        self.assertTrue(result.success)\n        \n        # 检查是否发现了时间序列问题\n        timing_issues = [i for i in result.issues_found if i.validation_type == ValidationType.TIMING]\n        self.assertGreater(len(timing_issues), 0)\n    \n    def test_auto_fix_functionality(self):\n        \"\"\"测试自动修复功能\"\"\"\n        # 创建可以自动修复的问题\n        fixable_subtitle = SubtitleEntry(\n            index=1,\n            start_time=0.0,\n            end_time=0.5,  # 时长过短，可以自动修复\n            text=\"  Text with spaces  \",  # 格式问题，可以自动修复\n            speaker=\"Test\"\n        )\n        \n        request = ValidationRequest(\n            request_id=\"auto_fix_test\",\n            subtitle_entries=[fixable_subtitle],\n            target_language=\"en\",\n            auto_fix=True,\n            fix_threshold=ValidationSeverity.HIGH\n        )\n        \n        result = asyncio.run(self.validator.validate_subtitles(request))\n        \n        self.assertTrue(result.success)\n        self.assertGreater(len(result.fixed_issues), 0)\n        self.assertIsNotNone(result.fixed_subtitles)\n        \n        # 检查修复后的字幕\n        if result.fixed_subtitles:\n            fixed_subtitle = result.fixed_subtitles[0]\n            # 时长应该被延长\n            self.assertGreater(fixed_subtitle.duration_seconds, fixable_subtitle.duration_seconds)\n            # 文本格式应该被清理\n            self.assertEqual(fixed_subtitle.text.strip(), fixed_subtitle.text)\n    \n    def test_validation_score_calculation(self):\n        \"\"\"测试验证分数计算\"\"\"\n        # 测试完美字幕（无问题）\n        perfect_subtitle = SubtitleEntry(\n            index=1,\n            start_time=0.0,\n            end_time=3.0,\n            text=\"Perfect subtitle.\",\n            speaker=\"Test\"\n        )\n        \n        request = ValidationRequest(\n            request_id=\"perfect_test\",\n            subtitle_entries=[perfect_subtitle],\n            target_language=\"en\"\n        )\n        \n        result = asyncio.run(self.validator.validate_subtitles(request))\n        \n        self.assertTrue(result.success)\n        self.assertEqual(result.validation_score, 1.0)  # 完美分数\n        \n        # 测试有问题的字幕\n        problematic_request = ValidationRequest(\n            request_id=\"problematic_test\",\n            subtitle_entries=self.test_subtitles,  # 包含各种问题\n            target_language=\"en\"\n        )\n        \n        problematic_result = asyncio.run(self.validator.validate_subtitles(problematic_request))\n        \n        self.assertTrue(problematic_result.success)\n        self.assertLess(problematic_result.validation_score, 1.0)  # 分数应该低于完美\n        self.assertGreater(problematic_result.validation_score, 0.0)  # 但不应该为0\n    \n    def test_custom_rules(self):\n        \"\"\"测试自定义规则\"\"\"\n        # 添加自定义规则\n        custom_rule = ValidationRule(\n            rule_id=\"custom_test_rule\",\n            rule_name=\"测试自定义规则\",\n            validation_type=ValidationType.CHARACTER_COUNT,\n            severity=ValidationSeverity.MEDIUM,\n            fix_strategy=FixStrategy.SUGGEST_FIX,\n            description=\"这是一个测试规则\",\n            parameters={\"max_chars\": 20}  # 很严格的字符限制\n        )\n        \n        # 添加规则\n        result = self.validator.add_custom_rule(custom_rule)\n        self.assertTrue(result)\n        self.assertEqual(len(self.validator.custom_rules), 1)\n        \n        # 移除规则\n        remove_result = self.validator.remove_custom_rule(\"custom_test_rule\")\n        self.assertTrue(remove_result)\n        self.assertEqual(len(self.validator.custom_rules), 0)\n    \n    def test_language_specific_validation(self):\n        \"\"\"测试语言特定验证\"\"\"\n        # 中文字幕测试\n        chinese_subtitle = SubtitleEntry(\n            index=1,\n            start_time=0.0,\n            end_time=3.0,\n            text=\"这是一个很长的中文字幕，用来测试中文语言的字符数限制和阅读速度验证功能。\",\n            speaker=\"主持人\"\n        )\n        \n        # 英文验证\n        en_request = ValidationRequest(\n            request_id=\"en_test\",\n            subtitle_entries=[chinese_subtitle],\n            target_language=\"en\"\n        )\n        \n        en_result = asyncio.run(self.validator.validate_subtitles(en_request))\n        \n        # 中文验证\n        zh_request = ValidationRequest(\n            request_id=\"zh_test\",\n            subtitle_entries=[chinese_subtitle],\n            target_language=\"zh\"\n        )\n        \n        zh_result = asyncio.run(self.validator.validate_subtitles(zh_request))\n        \n        # 两种语言的验证结果可能不同\n        self.assertTrue(en_result.success)\n        self.assertTrue(zh_result.success)\n    \n    def test_validation_statistics(self):\n        \"\"\"测试验证统计\"\"\"\n        # 执行几次验证来收集统计数据\n        for i in range(3):\n            request = ValidationRequest(\n                request_id=f\"stats_test_{i}\",\n                subtitle_entries=self.test_subtitles[:2],\n                target_language=\"en\"\n            )\n            asyncio.run(self.validator.validate_subtitles(request))\n        \n        stats = self.validator.get_validation_statistics()\n        \n        self.assertEqual(stats[\"total_validations\"], 3)\n        self.assertIn(\"average_validation_score\", stats)\n        self.assertIn(\"average_processing_time_ms\", stats)\n        self.assertIn(\"total_rules\", stats)\n        self.assertGreater(stats[\"total_rules\"], 0)\n    \n    def test_export_functionality(self):\n        \"\"\"测试导出功能\"\"\"\n        request = ValidationRequest(\n            request_id=\"export_test\",\n            subtitle_entries=self.test_subtitles,\n            target_language=\"en\"\n        )\n        \n        result = asyncio.run(self.validator.validate_subtitles(request))\n        \n        if result.issues_found:\n            # 测试JSON导出\n            json_report = self.validator.export_validation_report(result.issues_found, \"json\")\n            self.assertIn(\"report_id\", json_report)\n            self.assertIn(\"total_issues\", json_report)\n            \n            # 测试CSV导出\n            csv_report = self.validator.export_validation_report(result.issues_found, \"csv\")\n            self.assertIn(\"Issue ID\", csv_report)\n            \n            # 测试文本导出\n            text_report = self.validator.export_validation_report(result.issues_found, \"text\")\n            self.assertIn(\"字幕显示验证报告\", text_report)\n    \n    def test_encoding_detection(self):\n        \"\"\"测试编码检测\"\"\"\n        # 测试UTF-8编码\n        utf8_content = \"这是UTF-8编码的文本\".encode('utf-8')\n        detected_encoding = self.validator.detect_encoding(utf8_content)\n        self.assertIn(detected_encoding.lower(), ['utf-8', 'utf8'])\n        \n        # 测试GBK编码\n        try:\n            gbk_content = \"这是GBK编码的文本\".encode('gbk')\n            detected_encoding = self.validator.detect_encoding(gbk_content)\n            self.assertIsNotNone(detected_encoding)\n        except UnicodeEncodeError:\n            # 如果系统不支持GBK编码，跳过这个测试\n            pass\n    \n    def test_comprehensive_validation(self):\n        \"\"\"测试综合验证\"\"\"\n        request = ValidationRequest(\n            request_id=\"comprehensive_test\",\n            subtitle_entries=self.test_subtitles,\n            target_language=\"en\",\n            auto_fix=True\n        )\n        \n        result = asyncio.run(self.validator.validate_subtitles(request))\n        \n        self.assertTrue(result.success)\n        self.assertIsNotNone(result.validation_score)\n        self.assertIsInstance(result.issues_found, list)\n        self.assertIsInstance(result.fixed_issues, list)\n        self.assertIsInstance(result.recommendations, list)\n        self.assertGreater(result.processing_time_ms, 0)\n        \n        # 检查统计信息\n        self.assertIsInstance(result.issues_by_type, dict)\n        self.assertIsInstance(result.issues_by_severity, dict)\n        \n        # 检查元数据\n        self.assertIn(\"subtitles_count\", result.metadata)\n        self.assertIn(\"rules_applied\", result.metadata)\n        self.assertIn(\"language\", result.metadata)\n\n\nif __name__ == '__main__':\n    unittest.main()"